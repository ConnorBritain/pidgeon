// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using Segmint.Core.HL7;
using Segmint.Core.HL7.Types;

namespace Segmint.Core.HL7.Validation;

/// <summary>
/// Base class for field validators.
/// </summary>
public abstract class BaseFieldValidator : BaseValidator<HL7Field>, IFieldValidator
{
    /// <inheritdoc />
    public abstract IEnumerable<string> SupportedFieldTypes { get; }
    
    /// <inheritdoc />
    public virtual bool CanValidate(HL7Field field)
    {
        return SupportedFieldTypes.Contains(field.DataType);
    }
    
    /// <inheritdoc />
    public override ValidationResult Validate(HL7Field field)
    {
        if (!CanValidate(field))
        {
            return ValidationResult.Success();
        }
        
        var issues = new List<ValidationIssue>();
        
        // Basic field validation
        var basicIssues = ValidateBasicField(field);
        issues.AddRange(basicIssues);
        
        // Type-specific validation
        var typeIssues = ValidateFieldType(field);
        issues.AddRange(typeIssues);
        
        return CreateResult(issues);
    }
    
    /// <summary>
    /// Validates basic field properties.
    /// </summary>
    /// <param name="field">The field to validate.</param>
    /// <returns>A list of validation issues.</returns>
    protected virtual List<ValidationIssue> ValidateBasicField(HL7Field field)
    {
        var issues = new List<ValidationIssue>();
        var location = field.DataType;
        
        // Required field validation
        var requiredIssue = ValidateRequired(field, location);
        if (requiredIssue != null) issues.Add(requiredIssue);
        
        // Max length validation
        var lengthIssue = ValidateMaxLength(field, location);
        if (lengthIssue != null) issues.Add(lengthIssue);
        
        return issues;
    }
    
    /// <summary>
    /// Validates field type-specific properties.
    /// </summary>
    /// <param name="field">The field to validate.</param>
    /// <returns>A list of validation issues.</returns>
    protected abstract List<ValidationIssue> ValidateFieldType(HL7Field field);
}

/// <summary>
/// Validator for String (ST) fields.
/// </summary>
public class StringFieldValidator : BaseFieldValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => [ValidationType.Syntax, ValidationType.Semantic];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedFieldTypes => ["ST"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateFieldType(HL7Field field)
    {
        var issues = new List<ValidationIssue>();
        var location = field.DataType;
        
        // Check for control characters
        var controlIssue = ValidateNoControlCharacters(field, location);
        if (controlIssue != null) issues.Add(controlIssue);
        
        return issues;
    }
}

/// <summary>
/// Validator for Timestamp (TS) fields.
/// </summary>
public class TimestampFieldValidator : BaseFieldValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Clinical];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedFieldTypes => ["TS"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateFieldType(HL7Field field)
    {
        var issues = new List<ValidationIssue>();
        var location = field.DataType;
        
        if (field is TimestampField timestampField && !timestampField.IsEmpty)
        {
            // Validate timestamp format
            var formatIssue = ValidateTimestampFormat(timestampField, location);
            if (formatIssue != null) issues.Add(formatIssue);
            
            // Validate timestamp value
            if (timestampField.Value.HasValue)
            {
                var valueIssue = ValidateReasonableDate(timestampField.Value.Value, location);
                if (valueIssue != null) issues.Add(valueIssue);
            }
        }
        
        return issues;
    }
    
    /// <summary>
    /// Validates timestamp format.
    /// </summary>
    /// <param name="field">The timestamp field.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A validation issue if the format is invalid, null otherwise.</returns>
    private static ValidationIssue? ValidateTimestampFormat(TimestampField field, string location)
    {
        if (string.IsNullOrEmpty(field.RawValue))
            return null;
        
        // HL7 timestamp patterns
        var patterns = new[]
        {
            @"^\d{8}$",                           // YYYYMMDD
            @"^\d{12}$",                          // YYYYMMDDHHMM
            @"^\d{14}$",                          // YYYYMMDDHHMMSS
            @"^\d{14}\.\d{1,4}$",                 // YYYYMMDDHHMMSS.SSSS
            @"^\d{14}[+-]\d{4}$",                 // YYYYMMDDHHMMSS+ZZZZ
            @"^\d{14}\.\d{1,4}[+-]\d{4}$"         // YYYYMMDDHHMMSS.SSSS+ZZZZ
        };
        
        var isValidFormat = patterns.Any(pattern => Regex.IsMatch(field.RawValue, pattern));
        
        if (!isValidFormat)
        {
            return SyntaxError("TS001", 
                $"Invalid timestamp format: {field.RawValue}", location)
                .WithValues(field.RawValue, "Expected: YYYYMMDD[HHMM[SS[.SSSS]]][+ZZZZ]");
        }
        
        return null;
    }
}

/// <summary>
/// Validator for Person Name (XPN) fields.
/// </summary>
public class PersonNameFieldValidator : BaseFieldValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Clinical];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedFieldTypes => ["XPN"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateFieldType(HL7Field field)
    {
        var issues = new List<ValidationIssue>();
        var location = field.DataType;
        
        if (field is PersonNameField nameField && !nameField.IsEmpty)
        {
            // Validate name components
            var componentIssues = ValidateNameComponents(nameField, location);
            issues.AddRange(componentIssues);
            
            // Validate name format
            var formatIssue = ValidateNameFormat(nameField, location);
            if (formatIssue != null) issues.Add(formatIssue);
        }
        
        return issues;
    }
    
    /// <summary>
    /// Validates name components.
    /// </summary>
    /// <param name="field">The person name field.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A list of validation issues.</returns>
    private static List<ValidationIssue> ValidateNameComponents(PersonNameField field, string location)
    {
        var issues = new List<ValidationIssue>();
        
        // Check for required last name
        if (string.IsNullOrEmpty(field.LastName))
        {
            issues.Add(SemanticError("XPN001", 
                "Last name is required", location));
        }
        
        // Validate name characters
        var namePattern = @"^[A-Za-z\s\-'\.]+$";
        
        if (!string.IsNullOrEmpty(field.LastName) && !Regex.IsMatch(field.LastName, namePattern))
        {
            issues.Add(SyntaxError("XPN002", 
                $"Invalid characters in last name: {field.LastName}", location));
        }
        
        if (!string.IsNullOrEmpty(field.FirstName) && !Regex.IsMatch(field.FirstName, namePattern))
        {
            issues.Add(SyntaxError("XPN003", 
                $"Invalid characters in first name: {field.FirstName}", location));
        }
        
        if (!string.IsNullOrEmpty(field.MiddleName) && !Regex.IsMatch(field.MiddleName, namePattern))
        {
            issues.Add(SyntaxError("XPN004", 
                $"Invalid characters in middle name: {field.MiddleName}", location));
        }
        
        return issues;
    }
    
    /// <summary>
    /// Validates name format.
    /// </summary>
    /// <param name="field">The person name field.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A validation issue if the format is invalid, null otherwise.</returns>
    private static ValidationIssue? ValidateNameFormat(PersonNameField field, string location)
    {
        // Check for excessive length
        var displayName = field.ToDisplayString();
        if (displayName.Length > 100)
        {
            return ClinicalWarning("XPN005", 
                $"Name is unusually long ({displayName.Length} characters)", location)
                .WithValues(displayName, "Consider abbreviating");
        }
        
        return null;
    }
}

/// <summary>
/// Validator for Telephone (XTN) fields.
/// </summary>
public class TelephoneFieldValidator : BaseFieldValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => [ValidationType.Syntax, ValidationType.Semantic];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedFieldTypes => ["XTN"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateFieldType(HL7Field field)
    {
        var issues = new List<ValidationIssue>();
        var location = field.DataType;
        
        if (field is TelephoneField phoneField && !phoneField.IsEmpty)
        {
            // Validate phone number format
            if (!string.IsNullOrEmpty(phoneField.PhoneNumber))
            {
                var phoneIssue = ValidatePhoneNumber(phoneField.PhoneNumber, location);
                if (phoneIssue != null) issues.Add(phoneIssue);
            }
            
            // Validate email format
            if (!string.IsNullOrEmpty(phoneField.EmailAddress))
            {
                var emailIssue = ValidateEmailAddress(phoneField.EmailAddress, location);
                if (emailIssue != null) issues.Add(emailIssue);
            }
            
            // Validate use code
            if (!string.IsNullOrEmpty(phoneField.UseCode))
            {
                var useCodeIssue = ValidateUseCode(phoneField.UseCode, location);
                if (useCodeIssue != null) issues.Add(useCodeIssue);
            }
        }
        
        return issues;
    }
    
    /// <summary>
    /// Validates phone number format.
    /// </summary>
    /// <param name="phoneNumber">The phone number to validate.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A validation issue if the format is invalid, null otherwise.</returns>
    private static ValidationIssue? ValidatePhoneNumber(string phoneNumber, string location)
    {
        var phonePattern = @"^[+]?[\d\s\-\(\)\.]+$";
        
        if (!Regex.IsMatch(phoneNumber, phonePattern))
        {
            return SyntaxError("XTN001", 
                $"Invalid phone number format: {phoneNumber}", location)
                .WithValues(phoneNumber, "Expected: digits, spaces, hyphens, parentheses, periods");
        }
        
        return null;
    }
    
    /// <summary>
    /// Validates email address format.
    /// </summary>
    /// <param name="emailAddress">The email address to validate.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A validation issue if the format is invalid, null otherwise.</returns>
    private static ValidationIssue? ValidateEmailAddress(string emailAddress, string location)
    {
        var emailPattern = @"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$";
        
        if (!Regex.IsMatch(emailAddress, emailPattern))
        {
            return SyntaxError("XTN002", 
                $"Invalid email address format: {emailAddress}", location)
                .WithValues(emailAddress, "Expected: valid email format");
        }
        
        return null;
    }
    
    /// <summary>
    /// Validates use code.
    /// </summary>
    /// <param name="useCode">The use code to validate.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A validation issue if the use code is invalid, null otherwise.</returns>
    private static ValidationIssue? ValidateUseCode(string useCode, string location)
    {
        var validUseCodes = new[] { "PRN", "WPN", "ASN", "EMR", "NET", "BPN", "VHN" };
        
        if (!validUseCodes.Contains(useCode))
        {
            return SemanticError("XTN003", 
                $"Invalid use code: {useCode}", location)
                .WithValues(useCode, $"Valid codes: {string.Join(", ", validUseCodes)}");
        }
        
        return null;
    }
}

/// <summary>
/// Validator for Extended Composite ID (CX) fields.
/// </summary>
public class ExtendedCompositeIdFieldValidator : BaseFieldValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => [ValidationType.Syntax, ValidationType.Semantic];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedFieldTypes => ["CX"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateFieldType(HL7Field field)
    {
        var issues = new List<ValidationIssue>();
        var location = field.DataType;
        
        if (field is ExtendedCompositeIdField idField && !idField.IsEmpty)
        {
            // Validate ID number
            if (string.IsNullOrEmpty(idField.IdNumber))
            {
                issues.Add(SemanticError("CX001", 
                    "ID number is required", location));
            }
            
            // Validate identifier type code
            if (!string.IsNullOrEmpty(idField.IdentifierTypeCode))
            {
                var typeCodeIssue = ValidateIdentifierTypeCode(idField.IdentifierTypeCode, location);
                if (typeCodeIssue != null) issues.Add(typeCodeIssue);
            }
            
            // Validate check digit scheme
            if (!string.IsNullOrEmpty(idField.CheckDigitScheme))
            {
                var schemeIssue = ValidateCheckDigitScheme(idField.CheckDigitScheme, location);
                if (schemeIssue != null) issues.Add(schemeIssue);
            }
        }
        
        return issues;
    }
    
    /// <summary>
    /// Validates identifier type code.
    /// </summary>
    /// <param name="typeCode">The identifier type code to validate.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A validation issue if the type code is invalid, null otherwise.</returns>
    private static ValidationIssue? ValidateIdentifierTypeCode(string typeCode, string location)
    {
        var validTypeCodes = new[] { "MR", "PI", "AN", "VN", "SS", "DL", "PPN", "PRN", "MC", "MA" };
        
        if (!validTypeCodes.Contains(typeCode))
        {
            return SemanticError("CX002", 
                $"Invalid identifier type code: {typeCode}", location)
                .WithValues(typeCode, $"Valid codes: {string.Join(", ", validTypeCodes)}");
        }
        
        return null;
    }
    
    /// <summary>
    /// Validates check digit scheme.
    /// </summary>
    /// <param name="scheme">The check digit scheme to validate.</param>
    /// <param name="location">The field location.</param>
    /// <returns>A validation issue if the scheme is invalid, null otherwise.</returns>
    private static ValidationIssue? ValidateCheckDigitScheme(string scheme, string location)
    {
        var validSchemes = new[] { "ISO", "M10", "M11", "NPI" };
        
        if (!validSchemes.Contains(scheme))
        {
            return SemanticError("CX003", 
                $"Invalid check digit scheme: {scheme}", location)
                .WithValues(scheme, $"Valid schemes: {string.Join(", ", validSchemes)}");
        }
        
        return null;
    }
}

/// <summary>
/// Validator for Coded Value (IS) fields.
/// </summary>
public class CodedValueFieldValidator : BaseFieldValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => [ValidationType.Syntax, ValidationType.Semantic];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedFieldTypes => ["IS"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateFieldType(HL7Field field)
    {
        var issues = new List<ValidationIssue>();
        var location = field.DataType;
        
        if (field is CodedValueField codedField && !codedField.IsEmpty)
        {
            // Validate against allowed values
            if (codedField.AllowedValues != null && !codedField.AllowedValues.Contains(codedField.RawValue))
            {
                issues.Add(SemanticError("IS001", 
                    $"Invalid coded value: {codedField.RawValue}", location)
                    .WithValues(codedField.RawValue, $"Allowed values: {string.Join(", ", codedField.AllowedValues)}"));
            }
        }
        
        return issues;
    }
}