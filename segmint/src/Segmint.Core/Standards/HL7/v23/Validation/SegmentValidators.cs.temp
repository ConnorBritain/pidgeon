// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

using System;
using System.Collections.Generic;
using System.Linq;
using Segmint.Core.HL7.Segments;

namespace Segmint.Core.HL7.Validation;

/// <summary>
/// Base class for segment validators.
/// </summary>
public abstract class BaseSegmentValidator : BaseValidator<HL7Segment>, ISegmentValidator
{
    /// <inheritdoc />
    public abstract IEnumerable<string> SupportedSegmentIds { get; }
    
    /// <inheritdoc />
    public virtual bool CanValidate(HL7Segment segment)
    {
        return SupportedSegmentIds.Contains(segment.SegmentId);
    }
    
    /// <inheritdoc />
    public override ValidationResult Validate(HL7Segment segment)
    {
        if (!CanValidate(segment))
        {
            return ValidationResult.Success();
        }
        
        var issues = new List<ValidationIssue>();
        
        // Basic segment validation
        var basicIssues = ValidateBasicSegment(segment);
        issues.AddRange(basicIssues);
        
        // Segment-specific validation
        var segmentIssues = ValidateSegmentType(segment);
        issues.AddRange(segmentIssues);
        
        return CreateResult(issues);
    }
    
    /// <summary>
    /// Validates basic segment properties.
    /// </summary>
    /// <param name="segment">The segment to validate.</param>
    /// <returns>A list of validation issues.</returns>
    protected virtual List<ValidationIssue> ValidateBasicSegment(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        // Validate segment ID
        if (string.IsNullOrWhiteSpace(segment.SegmentId))
        {
            issues.Add(SyntaxError("SEG001", "Segment ID is required", location));
        }
        
        // Validate segment length
        if (segment.SegmentId.Length != 3)
        {
            issues.Add(SyntaxError("SEG002", 
                $"Segment ID must be 3 characters, got {segment.SegmentId.Length}", location));
        }
        
        // Validate required fields
        for (int i = 0; i < segment.FieldCount; i++)
        {
            var field = segment.GetField(i);
            if (field.IsRequired && field.IsEmpty)
            {
                issues.Add(SemanticError("SEG003", 
                    $"Required field {i + 1} is empty", $"{location}.{i + 1}"));
            }
        }
        
        return issues;
    }
    
    /// <summary>
    /// Validates segment type-specific properties.
    /// </summary>
    /// <param name="segment">The segment to validate.</param>
    /// <returns>A list of validation issues.</returns>
    protected abstract List<ValidationIssue> ValidateSegmentType(HL7Segment segment);
}

/// <summary>
/// Validator for MSH (Message Header) segments.
/// </summary>
public class MSHSegmentValidator : BaseSegmentValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => 
        [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Interface];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedSegmentIds => ["MSH"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateSegmentType(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        if (segment is MSHSegment mshSegment)
        {
            // Validate field separator
            if (mshSegment.FieldSeparator != "|")
            {
                issues.Add(SyntaxError("MSH001", 
                    $"Field separator must be '|', got '{mshSegment.FieldSeparator}'", $"{location}.1"));
            }
            
            // Validate encoding characters
            if (mshSegment.EncodingCharacters != "^~\\&")
            {
                issues.Add(SyntaxError("MSH002", 
                    $"Encoding characters must be '^~\\&', got '{mshSegment.EncodingCharacters}'", $"{location}.2"));
            }
            
            // Validate sending application
            if (mshSegment.SendingApplication.IsEmpty)
            {
                issues.Add(SemanticError("MSH003", 
                    "Sending application is required", $"{location}.3"));
            }
            
            // Validate receiving application
            if (mshSegment.ReceivingApplication.IsEmpty)
            {
                issues.Add(SemanticError("MSH004", 
                    "Receiving application is required", $"{location}.5"));
            }
            
            // Validate message type
            if (mshSegment.MessageType.IsEmpty)
            {
                issues.Add(SemanticError("MSH005", 
                    "Message type is required", $"{location}.9"));
            }
            
            // Validate message control ID
            if (mshSegment.MessageControlId.IsEmpty)
            {
                issues.Add(SemanticError("MSH006", 
                    "Message control ID is required", $"{location}.10"));
            }
            
            // Validate processing ID
            if (mshSegment.ProcessingId.IsEmpty)
            {
                issues.Add(SemanticError("MSH007", 
                    "Processing ID is required", $"{location}.11"));
            }
            
            // Validate version ID
            if (mshSegment.VersionId.IsEmpty)
            {
                issues.Add(SemanticError("MSH008", 
                    "Version ID is required", $"{location}.12"));
            }
        }
        
        return issues;
    }
}

/// <summary>
/// Validator for PID (Patient Identification) segments.
/// </summary>
public class PIDSegmentValidator : BaseSegmentValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => 
        [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Clinical];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedSegmentIds => ["PID"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateSegmentType(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        if (segment is PIDSegment pidSegment)
        {
            // Validate patient ID
            if (pidSegment.PatientIdList.IsEmpty)
            {
                issues.Add(SemanticError("PID001", 
                    "Patient ID is required", $"{location}.3"));
            }
            
            // Validate patient name
            if (pidSegment.PatientName.IsEmpty)
            {
                issues.Add(SemanticError("PID002", 
                    "Patient name is required", $"{location}.5"));
            }
            
            // Validate date of birth
            if (pidSegment.DateOfBirth.IsEmpty)
            {
                issues.Add(ClinicalWarning("PID003", 
                    "Date of birth is missing", $"{location}.7"));
            }
            else if (pidSegment.DateOfBirth.Value.HasValue)
            {
                var birthDate = pidSegment.DateOfBirth.Value.Value;
                var birthDateIssue = ValidateBirthDate(birthDate, $"{location}.7");
                if (birthDateIssue != null) issues.Add(birthDateIssue);
            }
            
            // Validate sex
            if (!pidSegment.Sex.IsEmpty)
            {
                var validSexCodes = new[] { "M", "F", "U", "O" };
                if (!validSexCodes.Contains(pidSegment.Sex.RawValue))
                {
                    issues.Add(SemanticError("PID004", 
                        $"Invalid sex code: {pidSegment.Sex.RawValue}", $"{location}.8")
                        .WithValues(pidSegment.Sex.RawValue, "Valid codes: M, F, U, O"));
                }
            }
            
            // Validate SSN format if present
            if (!pidSegment.SSN.IsEmpty)
            {
                var ssnPattern = @"^\d{3}-\d{2}-\d{4}$|^\d{9}$";
                if (!System.Text.RegularExpressions.Regex.IsMatch(pidSegment.SSN.RawValue, ssnPattern))
                {
                    issues.Add(SyntaxError("PID005", 
                        $"Invalid SSN format: {pidSegment.SSN.RawValue}", $"{location}.19")
                        .WithValues(pidSegment.SSN.RawValue, "Expected: XXX-XX-XXXX or XXXXXXXXX"));
                }
            }
        }
        
        return issues;
    }
}

/// <summary>
/// Validator for PV1 (Patient Visit) segments.
/// </summary>
public class PV1SegmentValidator : BaseSegmentValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => 
        [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Clinical];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedSegmentIds => ["PV1"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateSegmentType(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        if (segment is PV1Segment pv1Segment)
        {
            // Validate patient class
            if (pv1Segment.PatientClass.IsEmpty)
            {
                issues.Add(SemanticError("PV1001", 
                    "Patient class is required", $"{location}.2"));
            }
            else
            {
                var validClasses = new[] { "E", "I", "O", "P", "R", "B", "N" };
                if (!validClasses.Contains(pv1Segment.PatientClass.RawValue))
                {
                    issues.Add(SemanticError("PV1002", 
                        $"Invalid patient class: {pv1Segment.PatientClass.RawValue}", $"{location}.2")
                        .WithValues(pv1Segment.PatientClass.RawValue, "Valid classes: E, I, O, P, R, B, N"));
                }
            }
            
            // Validate admission date
            if (!pv1Segment.AdmitDateTime.IsEmpty && pv1Segment.AdmitDateTime.Value.HasValue)
            {
                var admitDate = pv1Segment.AdmitDateTime.Value.Value;
                var admitDateIssue = ValidateReasonableDate(admitDate, $"{location}.44");
                if (admitDateIssue != null) issues.Add(admitDateIssue);
                
                // Check for future admission dates
                if (admitDate > DateTime.Now)
                {
                    issues.Add(ClinicalWarning("PV1003", 
                        "Admission date is in the future", $"{location}.44")
                        .WithValues(admitDate.ToString("yyyy-MM-dd"), "Future admissions should be verified"));
                }
            }
            
            // Validate discharge date
            if (!pv1Segment.DischargeDateTime.IsEmpty && pv1Segment.DischargeDateTime.Value.HasValue)
            {
                var dischargeDate = pv1Segment.DischargeDateTime.Value.Value;
                var dischargeDateIssue = ValidateReasonableDate(dischargeDate, $"{location}.45");
                if (dischargeDateIssue != null) issues.Add(dischargeDateIssue);
                
                // Check discharge before admission
                if (!pv1Segment.AdmitDateTime.IsEmpty && pv1Segment.AdmitDateTime.Value.HasValue)
                {
                    if (dischargeDate < pv1Segment.AdmitDateTime.Value.Value)
                    {
                        issues.Add(ClinicalWarning("PV1004", 
                            "Discharge date is before admission date", $"{location}.45")
                            .WithValues(dischargeDate.ToString("yyyy-MM-dd"), "Verify chronological order"));
                    }
                }
            }
            
            // Validate visit number
            if (!pv1Segment.VisitNumber.IsEmpty)
            {
                var visitNumber = pv1Segment.VisitNumber.IdNumber;
                if (string.IsNullOrWhiteSpace(visitNumber))
                {
                    issues.Add(SemanticError("PV1005", 
                        "Visit number ID is required when visit number is present", $"{location}.5"));
                }
            }
        }
        
        return issues;
    }
}

/// <summary>
/// Validator for NTE (Notes and Comments) segments.
/// </summary>
public class NTESegmentValidator : BaseSegmentValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => 
        [ValidationType.Syntax, ValidationType.Semantic];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedSegmentIds => ["NTE"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateSegmentType(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        if (segment is NTESegment nteSegment)
        {
            // Validate comment text
            if (nteSegment.Comment.IsEmpty)
            {
                issues.Add(SemanticError("NTE001", 
                    "Comment text is required", $"{location}.3"));
            }
            
            // Validate comment length
            if (!nteSegment.Comment.IsEmpty && nteSegment.Comment.RawValue.Length > 1000)
            {
                issues.Add(ClinicalWarning("NTE002", 
                    $"Comment is very long ({nteSegment.Comment.RawValue.Length} characters)", $"{location}.3")
                    .WithValues(nteSegment.Comment.RawValue, "Consider breaking into multiple NTE segments"));
            }
            
            // Validate comment type if present
            if (!nteSegment.CommentType.IsEmpty)
            {
                var validTypes = new[] { "PI", "AI", "GI", "RE", "DR", "GR" };
                if (!validTypes.Contains(nteSegment.CommentType.RawValue))
                {
                    issues.Add(SemanticError("NTE003", 
                        $"Invalid comment type: {nteSegment.CommentType.RawValue}", $"{location}.4")
                        .WithValues(nteSegment.CommentType.RawValue, "Valid types: PI, AI, GI, RE, DR, GR"));
                }
            }
        }
        
        return issues;
    }
}

/// <summary>
/// Validator for ORC (Common Order) segments.
/// </summary>
public class ORCSegmentValidator : BaseSegmentValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => 
        [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Clinical];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedSegmentIds => ["ORC"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateSegmentType(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        if (segment is ORCSegment orcSegment)
        {
            // Validate order control
            if (orcSegment.OrderControl.IsEmpty)
            {
                issues.Add(SemanticError("ORC001", 
                    "Order control is required", $"{location}.1"));
            }
            else
            {
                var validControls = new[] { "NW", "OK", "UA", "CA", "OC", "CR", "DC", "DE", "DF", "DR", "FU", "HD", "HR", "LI", "NA", "NF", "OR", "PA", "RE", "RL", "RO", "RP", "RQ", "RR", "RU", "SN", "SR", "SS", "UA", "UC", "UD", "UF", "UH", "UM", "UN", "UP", "UR", "UX", "XO", "XR" };
                if (!validControls.Contains(orcSegment.OrderControl.RawValue))
                {
                    issues.Add(SemanticError("ORC002", 
                        $"Invalid order control: {orcSegment.OrderControl.RawValue}", $"{location}.1")
                        .WithValues(orcSegment.OrderControl.RawValue, "See HL7 Table 0119 for valid values"));
                }
            }
            
            // Validate placer order number
            if (!orcSegment.PlacerOrderNumber.IsEmpty && string.IsNullOrWhiteSpace(orcSegment.PlacerOrderNumber.EntityIdentifier))
            {
                issues.Add(SemanticError("ORC003", 
                    "Placer order number entity identifier is required when placer order number is present", $"{location}.2"));
            }
            
            // Validate filler order number
            if (!orcSegment.FillerOrderNumber.IsEmpty && string.IsNullOrWhiteSpace(orcSegment.FillerOrderNumber.EntityIdentifier))
            {
                issues.Add(SemanticError("ORC004", 
                    "Filler order number entity identifier is required when filler order number is present", $"{location}.3"));
            }
            
            // Validate order status
            if (!orcSegment.OrderStatus.IsEmpty)
            {
                var validStatuses = new[] { "A", "CA", "CM", "DC", "ER", "HD", "IP", "RP", "SC" };
                if (!validStatuses.Contains(orcSegment.OrderStatus.RawValue))
                {
                    issues.Add(SemanticError("ORC005", 
                        $"Invalid order status: {orcSegment.OrderStatus.RawValue}", $"{location}.5")
                        .WithValues(orcSegment.OrderStatus.RawValue, "Valid statuses: A, CA, CM, DC, ER, HD, IP, RP, SC"));
                }
            }
            
            // Validate entered date
            if (!orcSegment.EnteredDate.IsEmpty && orcSegment.EnteredDate.Value.HasValue)
            {
                var enteredDate = orcSegment.EnteredDate.Value.Value;
                var enteredDateIssue = ValidateReasonableDate(enteredDate, $"{location}.9");
                if (enteredDateIssue != null) issues.Add(enteredDateIssue);
            }
        }
        
        return issues;
    }
}

/// <summary>
/// Validator for RXE (Pharmacy/Treatment Encoded Order) segments.
/// </summary>
public class RXESegmentValidator : BaseSegmentValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => 
        [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Clinical];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedSegmentIds => ["RXE"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateSegmentType(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        if (segment is RXESegment rxeSegment)
        {
            // Validate give code
            if (rxeSegment.GiveCode.IsEmpty)
            {
                issues.Add(SemanticError("RXE001", 
                    "Give code (medication) is required", $"{location}.2"));
            }
            
            // Validate give amount minimum
            if (rxeSegment.GiveAmountMinimum.IsEmpty)
            {
                issues.Add(SemanticError("RXE002", 
                    "Give amount minimum is required", $"{location}.3"));
            }
            
            // Validate give units
            if (rxeSegment.GiveUnits.IsEmpty)
            {
                issues.Add(SemanticError("RXE003", 
                    "Give units are required", $"{location}.5"));
            }
            
            // Validate dosage form
            if (!rxeSegment.DosageForm.IsEmpty)
            {
                var validForms = new[] { "TAB", "CAP", "SYR", "INJ", "CRE", "OIN", "SOL", "SUS", "LOZ", "SUP", "INH", "PAT", "GEL", "LOT", "FOA", "SPR", "DRO", "ELX", "TIN", "SHM", "POW", "GRA", "FLM", "BAR", "WAF", "GUM", "PAS", "IMP", "CON", "KIT", "SYS", "DEV" };
                if (!validForms.Contains(rxeSegment.DosageForm.RawValue))
                {
                    issues.Add(ClinicalWarning("RXE004", 
                        $"Unusual dosage form: {rxeSegment.DosageForm.RawValue}", $"{location}.6")
                        .WithValues(rxeSegment.DosageForm.RawValue, "Verify dosage form is correct"));
                }
            }
            
            // Validate date/time of first dose
            if (!rxeSegment.DateTimeOfFirstDose.IsEmpty && rxeSegment.DateTimeOfFirstDose.Value.HasValue)
            {
                var firstDoseDate = rxeSegment.DateTimeOfFirstDose.Value.Value;
                var firstDoseDateIssue = ValidateReasonableDate(firstDoseDate, $"{location}.9");
                if (firstDoseDateIssue != null) issues.Add(firstDoseDateIssue);
            }
            
            // Validate quantity/timing
            if (!rxeSegment.QuantityTiming.IsEmpty)
            {
                // Basic validation for quantity/timing format
                if (string.IsNullOrWhiteSpace(rxeSegment.QuantityTiming.Quantity))
                {
                    issues.Add(SemanticError("RXE005", 
                        "Quantity is required in quantity/timing", $"{location}.1"));
                }
                
                if (string.IsNullOrWhiteSpace(rxeSegment.QuantityTiming.Interval))
                {
                    issues.Add(SemanticError("RXE006", 
                        "Interval is required in quantity/timing", $"{location}.1"));
                }
            }
        }
        
        return issues;
    }
}

/// <summary>
/// Validator for MSA (Message Acknowledgment) segments.
/// </summary>
public class MSASegmentValidator : BaseSegmentValidator
{
    /// <inheritdoc />
    public override IEnumerable<ValidationType> SupportedTypes => 
        [ValidationType.Syntax, ValidationType.Semantic, ValidationType.Interface];
    
    /// <inheritdoc />
    public override IEnumerable<string> SupportedSegmentIds => ["MSA"];
    
    /// <inheritdoc />
    protected override List<ValidationIssue> ValidateSegmentType(HL7Segment segment)
    {
        var issues = new List<ValidationIssue>();
        var location = segment.SegmentId;
        
        if (segment is MSASegment msaSegment)
        {
            // Validate acknowledgment code
            if (msaSegment.AcknowledgmentCode.IsEmpty)
            {
                issues.Add(SemanticError("MSA001", 
                    "Acknowledgment code is required", $"{location}.1"));
            }
            else
            {
                var validCodes = new[] { "AA", "AE", "AR", "CA", "CE", "CR" };
                if (!validCodes.Contains(msaSegment.AcknowledgmentCode.RawValue))
                {
                    issues.Add(SemanticError("MSA002", 
                        $"Invalid acknowledgment code: {msaSegment.AcknowledgmentCode.RawValue}", $"{location}.1")
                        .WithValues(msaSegment.AcknowledgmentCode.RawValue, "Valid codes: AA, AE, AR, CA, CE, CR"));
                }
            }
            
            // Validate message control ID
            if (msaSegment.MessageControlId.IsEmpty)
            {
                issues.Add(SemanticError("MSA003", 
                    "Message control ID is required", $"{location}.2"));
            }
            
            // Validate error condition for error acknowledgments
            if (!msaSegment.AcknowledgmentCode.IsEmpty && 
                (msaSegment.AcknowledgmentCode.RawValue == "AE" || 
                 msaSegment.AcknowledgmentCode.RawValue == "AR" || 
                 msaSegment.AcknowledgmentCode.RawValue == "CE" || 
                 msaSegment.AcknowledgmentCode.RawValue == "CR"))
            {
                if (msaSegment.ErrorCondition.IsEmpty)
                {
                    issues.Add(InterfaceError("MSA004", 
                        "Error condition is required for error acknowledgments", $"{location}.6"));
                }
            }
        }
        
        return issues;
    }
}